/********************** 版权声明 *************************
 * 文件: DesHtmlUtil.java
 * 包名: com.hlframe.modules.dc.utils
 * 版权: 杭州华量软件 hldc_bigdata
 * 职责:	
 ********************************************************
 *
 * 创建者：peijd   创建时间：2017年05月24日 13:55
 * 文件版本：V1.0 
 *
 *******************************************************/
package com.hlframe.modules.dc.utils;

import java.util.ArrayList;
import java.util.List;

/**
 * com.hlframe.modules.dc.utils.Des
 * DES加密方法  对应前端的des.js
 *
 * @author peijd
 * @create 2017-05-24 13:55
 **/
public class Des {

    private static final String DEFAULT_DES_KEY = "hzhl_2017";
    public Des() {
    }

    public static void main(String[] args) {
        Des desObj = new Des();
        String key1 = "5CUf2yeUo3HA74GSlo3oNSHdYQ+ppR4Io/YcmYxc4Ct7V8c1s0PVsA==";
        String key2 = "";
        String key3 = "";
        String data = "BA55D020F4DF5EBE24B388BA50A24996495B67C0E9950BA00D28E41BC2D34592D499F717359186323CC8D4C95ABFD9CA3233E97D55652FA44723E8C9B37DAEFDF64528F3B9DDDC895C507682B144934C64B5BE7D6F70F3F02D2421B11B5451A8079D3A964B3D09F5C92BF8CE1ADFF6DA549E4F02087EB7D9D8739C90419FDBCC7281A521EC0FF1B2450690D0CBCB4BD428206F70D78FC02E2C3E5715A865730DFFC8F6E12F4A6EDE205850DF846CDA09A15954F524EEE0F4D1D620018F2AFDD970955C6EFD1386C6A7132EF950AECC4EA0739C8251690A5D08E23D22F08604F3404622D0DF4B8F6BC9F53996C95115B254AFB6FD6AE57DF733CA22F06500F98E3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A88BB293F1BE5899E2A04225C8F166F6110E838E2B15006FBE3405EABD9B2C95B5A12865F7A9C2E07401D7D5DDB6B67B101B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BCFDB1A361AD7E71DB4AAB2E8BAB07B74275792A4777FE54064AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54BDB329079F121A58E4185CF770DD9EC9AEB934CF8BA8FAB5EFF12E2FD850C44390B2B91852014DE74504C31EC7C8112E4B7FE9001C26AE21CC8C1B65536750D66C164B09B36352FEE3FC53E97F2BC97E10A913FF4EEBC52A7F0192975C1DFAC883BF7567D723B902B6D6B3802F5D19E6567A2CE82A06946BD8D6F40CD6B20F2D872D8BBF786F50B090518F1EFA74E61AED09F0A661A75BDAC6A36A4594574554E55FD7632D78D3C1B6D2865DDCD596A31601CB8CC7B6A202B261020F46F20B1049DA46DF7FACD9C816BC9DAA81A65F91EE4C5F93E8AD93F8BB5C181B791117E89C3D6CEC17DDF119AAA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB51192DC5ECF1A569CE8FF608552A834225FA0F8B52CCB2C6093B168B051C942C1F0ECA214E834D633EDB8621F7F566628D769311F0414A9A607DE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F2678FFCB31CF57576EC1843FB790E6FFC6D6031BD5924900B19EDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF17B90F0954C657E3D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C3955CF0BF0AEC98157910D4370ED9650B5F146CB4FB4B5DFB49331E07A35C55D4DE0B69CD15098F33017CD4250D663AD72FD3BCC4EAEA158BF7A7D20FBE7F3A2A2D839179B602EC98044945F94D8EA99A35E9E02BAEDF545E81A9D2ED58AFE37FFD7C2A41C5513DF93FA2A42715610B41F774B6911119F24399A7A2720A40A832AA1BC7920471FD328FA0EA84D5881A387CEE87A560E432715D898CAECA02EEE9D1EC4304CF50137D5D1A4546CE09BD171ED88895D54294C3ACB05AB28772D7EEA6C0C530546E330D886579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C7964885C61BD9455F12B6F2A04225C8F166F614FD981E652937A91E3405EABD9B2C95B5A12865F7A9C2E07401D7D5DDB6B67B101B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6B8804E7E85669D4E4021ABEFD846E37F6D4274D503A77962664AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54BF50F91F020845F0D1404D7F26EF74AC3D969D583335D04E191D398083EBF5B958E957AF13B9C8923473E6EA71909886151D91A99BF8C695BF16233C064507117A78E18F4591C46F7E2A583D4F3A5C2C641A57C644127F02C40BC4CDFA1EAE129CF231FACFE7F68FBD39744FA6E4D7DCB7192E4DC24DE09089A4456CDCD483D38F90BB84247A8D6B706BC559A5FFE971E25E1D0A772887E7069A355DDB7447FF0A847DDFABAC37DCF26DEE301996B0E8D6B777BBCFA99FE62BFF86143D6F939779F6D3C92A74A57107E59DBEAFA0658FA6937043C268465BCA5AAF30583E5023A5580F22213A391A6F3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998AF3E8D1B753745C46CFD160EABC5A1ABF62E673B9C3FC1BB6B689836E2498B4B1A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606ED03E137AB780A913D25BCD21B5EF740DE4D97CF0792843082E5041E2753E03E23D8762B11D337FD66BFD39BF379B12F4EC88DC47B3C36CE79311F0414A9A607DD499F717359186323CC8D4C95ABFD9CAECB1002FCA25B22CB792DB5A6BF0C3CEBB07A38A0D884FD1F8F58CACCF5881A5832877A0491FE3FF92D493D2311E7BDC04F3B3060A3B3EEB7C1FB0FADB9ECFE010CF1E42ACC8324FD40B16A4C214443C0DBE7DC81193E814618FB25B1C7138DAFAF3D3B0ECA42058F3F8FBF5BCFE7F75289E800709194C85D611CC509C98C6D262593F78586209774978E7684A26CF123068B0AEB9DB660424728FB90AAFAD4EA8F4E222C2C69B1C6EFD0E3AD4BB77283D70DDAD099133B9B0A2135613F80399377311BAC887EE5CBEB6A7E3EFBF7E7D3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431AFF67DDE1E771335FF608552A834225FA817586B4D406A8425BF7255C7DB59AF6CA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F267572BE20BCDA1BDEF001BC934F2EA28536CF1A4966DC8895DEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCFF4F2D7BF73D7F317D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C39557FD02BF6FF1484F16B1626A7599E3639227C93BC4C8DAB18F48315D1548E194CED6D4C1009FDAAB540C0D34FEBDD5D1287C0308BBE3767AAD6B31BF8E10F896CA47CF0DF67281B083069DB7CDA4A1FE9F9E7AE8DB7A77B8D8A3102E0F5F81F581166DB46716F8825FC5426E5E788EFDDD2DD1FD440BC7E2EAA066A9C68973509FC673D6E4D89BDD798F2D5F421B84E3D255C7D4DC72DB8CD0BA8340C4BCEC6E62761940D0D129174A815C49B0FC54E5BB53A79176CE4E43E80FC427B7B7E32BAB1E85BD2928E2F14579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C796488720733A5656582F22A04225C8F166F6136C1C6E6FB0ED858E3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BEA75CDBAE4F96367E43BEEC43017129ECEA65E9F193B1EEA64AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54B2AA351944754E03E1404D7F26EF74AC3D969D583335D04E10A78FC94A64D6D53224A1D0C5EFCD5285B333F92829B574FFAA53B02D3F4E0B61E136443510F9D8E1EC7D6EDB828430B80706C0261AB173E12B1E3E9D59830BC899BB8669E39E67593D062736CBAFC4468E39B4AA81839B3C3241DCEE569A23C76B437393FB43AAC91E0CDFBEE1CEA1A9E78A8A546F481DA54049473CE66C812817324B6775201FFAB322082D3CB71F7D20EE02D177522E52A9683817E1BC3031D1A3AF32869038D97E14F6891662253FB8148112F3A734A2C2D5757A06A2F3F89FD63B2EC94C4C7E7D3D302905966BBF3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998AF3E8D1B753745C4826318AA73DF6094F62E673B9C3FC1BB4D985269A9931535A74482DEBB586A0B56E91605833641EC96B0A4C7E3BC22807EAF1EA9227DD52F865A335A5770C3E287CBD80F3FCB64793F5BDD89524AD35DA8D11B1C1AF59BC0A6D7C832F979E0AC4D568E333C0C0DD56493449D0D269D8382C7ECE46A9D5B82E56D22C9E2FCE11924B388BA50A24996495B67C0E9950BA0CF7F130CF5761AE64185CF770DD9EC9AEB934CF8BA8FAB5ED8A8A5B8C4F0DC257A38AFEAE0424AAB86C285E81C460902170A68E833FB5532CCCF78CADD17C2B0F78968F3B94B6A25E26AD0EFC316E44E9B3CB6CE6FB67EC3E28C63D9FDD51E2C03EE1E9C8C7603E42D0C58D3BFCDAA59F55C4A6EDB7DCA19BA7A734A3308F0D8C6504C4E40A9C0A32DBEA8922AD9100D3CB478FF832E2EA418576F3332EADDD5E121DB376715355FAEE005237B469B14E41820D1D088346A05F11281B684F9308F5B495869B78428F02A4A8EF4EAA91C1EB18A78C0473F2FC015D9680EDCD490BEAA6356B684B7C5AA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB51194E3D462287179A9CC5106AE5D3BD5837604A5C95CC0493FF4728AE28FE8C734F1A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E8E32DA3B7E29215FB49B53ACD2A0ED4D974EF431F15988C10A2BB61B73DC2FF93D8762B11D337FD66BFD39BF379B12F4EC88DC47B3C36CE7F9A7296F707CB8BDD499F717359186323CC8D4C95ABFD9CA482CE15070677E9514F11EB950AAC0262A6203301847E8B7A57669372038EFAB22EE9A2E0ED8898055C29727FE20316BA0F302CBEA628355FDE6877E02C750A832CF583B9DB2A17CE1D63DC7F23311F63B2A21EAA0C2C04A21C4FE2CD06F51B5EF3D09333F048CC98982B7EA0FB5E95A2708A5457972A69FCA38E9460162D6A3109792AAAE3E7A2B80E9D3A90698B13AF1AEB081640894E0A44328583AE92AC3DB09278E3C9896E9AA39544D104F9D9BF72FA645BB9471559F16F89C37BAD465AB310CD0339157D9C855FAAE762701743A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A73717E6F786A1BF4F608552A834225FA0F8B52CCB2C6093BE3405EABD9B2C95B5A12865F7A9C2E07401D7D5DDB6B67B101B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BFEF66F5DC09CF6CE3C0409AB012981A64443C53EA62D00BC64AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54B5074656730AF08511404D7F26EF74AC3D969D583335D04E157FC35A20E79CF3436E8587E0FC58DBB4CF4D703725005CD7695ED4BC35EE3D38E72C5435C883195A3B950960B50A83BC9C42BB47E9A7CC81F83E907DE977E9A7A643B1C351F4F2F9C90E8036B9D3176280B843C17EAA61141D3045A8E4A03B7669E258C9B66ACFC6B1A523E227961CCC45096CDF33256C2CCDD04E399EF78E1C0815FB992B67434F5C6109ED730D90CA1D1FD4C34B7EEB3AE3B5B3549C56762063D25FBE49DD4E9E6848CB1B6ECAD9B8C61AABD2DA0A1B3A51BC665B81630A6E1F2388042C994800407FDA4214B8775F3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998AF3E8D1B753745C46B8D7D59992BA3E5F62E673B9C3FC1BB7EDF2D802F29AD991A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E521C295FC671AB741039735BF908A472F3CE20337A3966DB2E5041E2753E03E23D8762B11D337FD66BFD39BF379B12F4EC88DC47B3C36CE7C8734C847D1DBA02D499F717359186323CC8D4C95ABFD9CA7365E1DC9EB2DEAD23FBD27846B4814D144E93C8C57805F810A42609F95E10CB3144527217A7D02BAC3532ED110D47A9AD457FD8A2FD36A86174744C263F313CC9C1E8A4D51D84DB2F1A50F00649D226920B2FBE6AD6E1A529D8DD90B7CA4F9A5282509FAE8DB1B9AA3D18CFBD505105FBA64BC3E757697FC4819262D10CB3365DB79A3772A3DFBDA71735A2574C71D142F38C3884F647B4E4D7C81D2B4EA57D100E7F396CAA65636B214D9A908E3C3302FFF1DC33EFCED38DB53816EE64AF086A82F9577A293A3FA9EF99663EE2903F3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A06F759B7DA04B8DAF608552A834225FAE587B1214FE04201E86D197BA9E586CBCA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F26715083F8A0EB0461453AD2F126FC4D584BAD40CC3ED05088EEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF982366C503C15516D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C39554587278CB2F119DA43F0521CEB71795C7E262B74B02307242312DB6CE24C3F8A50DE58E08B3661E80E30C617B850D71F4BB4D82A9A906AE61EEDAF96F98C3F1DB04543B9F10B83EEB7CF016277C4F0CF5F94DD9C784DD922822C50EDD682A3080C4F52B724D2C37434CE6FC1C156BA39799BC2C4DDE951632FDB50FF1379C481A214C8CB9C308ED2B8A08D04ED5F3E389B6E43D04096E1023104D5F5F47ACD81639BD7900B6064BB54E560ACE353C5FDE0760B21ADD4CCE8C329FFCBEC7E39129DF0C7C60370C108579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C79648828BEE995D7FC518F2A04225C8F166F6128FC45AFF7870E60E3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BD0C4FBF184E1383C7B9BDC440073B35901357948CA60E3F164AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54BC381ED797C2A7ED04185CF770DD9EC9AEB934CF8BA8FAB5E45FDACFB54A0647C7FE3731688A2F37213038EDD7FD03BFE521315C5A492EA3BE6C5431780B8FB1015CF9F04BFF12C96DE63A23454E94CDDC2622716C9EA37ACE10F56E463F499395D4C386E906DCF9DBD6E278E94BE79081F44C9E2078960CA46A539129DD80EB6D71953D45D518D537E7B91BE26DD85B1F85489252AF700F0568D99DEEDC884906D0D74EBB74E5BD5EDB770EA42E2C7CF19B25B080CF3D16848E5C77C235BBD9ACF88B1D963ECAFBC984DAA63A571C330189C1A50A3C1B66ADDE43F3A3180037792AD2FECFC87AA90AA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB5119BA43236822385773F608552A834225FA72EE860B1D7150CE24A362E7792CE61ACA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F267DD1E12F4F3F08B3728D3C33D19813A37200BD46A95F8F2ADEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF07E571D6B33477BF1404D7F26EF74AC3D969D583335D04E10EE7A64FBDD3E55EE1122CCCBFFFA54A89F0877B001DB13BFDD2EC5A55ED95F3668078BEC652F7FB5D44E9E8C1376C721D0D5D4E2BB463576972AFE304B430F094775B6E76F5E12C17E679AEDFE9E24597A74B99058AB384BA190B06081F0CA7B538DD1D49CA399EEAD0DBBF14F9F09F46F7E96426FE9CAD73F3171F5AD90428612C3701E2DCEE777C326E88DBD0778E44F84ADD5A689DBBCB9202138A92BE53C185B2FAA39C23F786FA281CD4C3DBC9DDF4B179AF9A1E43E59DFCCAB9463E004427B4247FE257CA682B638CCB69FC12F3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998598F6C35880B3432C5106AE5D3BD5837604A5C95CC0493FF1365AE824CCD81631A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E4F16FFE29FE0E17256B1A474B6B91688BBD5A9322160E414FAC264972D6B4E2E3D8762B11D337FD66BFD39BF379B12F4ABBB62E12A7B02A5D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C3955C6F1F4CCCF65084C1EF97B74EA6ECAED5939E130514B2161F3D3D504842C2231BEC0AE8B487DEB982A447B41293BB53394F371F1EFE1342ECFF3F75C89CD6FE897730B8A24F301FE5E53AEA245EB1125D2F1E21A5F69E3B8A57C37C08C0C7A70D9AC04E6B397A5E11DFEDB17194809829DF6A733E3CC7AC0D9989C2B3D7ADE28E84269984158510EE20D7AB2824A01D363AB3797915288D0CE23A8EA67B709D5E04C2DC9E9771457BDD0F8FF13C8CDEA5EB5E57A7CD209F226044F39185875E38112F6DEE1F2E121579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C796488826318AA73DF6094F62E673B9C3FC1BB0E3DD6344B19344FA74482DEBB586A0B56E91605833641EC96B0A4C7E3BC22807EAF1EA9227DD52F865A335A5770C3E287CBD80F3FCB64793F5BDD89524AD35DA8D11B1C1AF59BC0A6D7C832F979E0AC36DF30658FDCD29753BDFF63A287DC7421FA8C2F930D5AB9E56D22C9E2FCE11924B388BA50A24996495B67C0E9950BA031A14A1A96F2CAD7D499F717359186323CC8D4C95ABFD9CAEE8791E5B748F838709783B2B8FD5A0EBEC886AE58AC81F642A41AD65BE070377B1B0AB75CA8CBF610B9D9F751264FF029EBCE873C929C6E65091FF3680A7DED07F0A4AAEB497CD39E01A677F01FF44D0695CB04DAB0FEB5CC438EC20F98DDF6A5D2A5B885D0BA746123E7B2003C65CA009BDFC2F1E67CC765F6C17670A9554B92F889ED111F1D786534ED59F2377D38FC8300586AAD17948C5AE4D48937A6E560AC2BBD2EFDD3AD573295C51DA056CC53444B958C18B8F81F0FBE3D45EA56A955D6FE7377E6C8948129428622D55C163A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A6601EF49D49B17A12A04225C8F166F61462EC305C6501E1CE3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BF6AD2BB40CC0365F8DACD914DE7EF5429C6CFD5802A7195C64AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54B706302C843FD23E94185CF770DD9EC9AEB934CF8BA8FAB5EDE38FFCA39356E1B84AD0F6D04564D939B0BD7B898D24666441134F9ADA8BF35EB45EABF21494FB7128FD53885B98047C0E2E9F6230E7E4D8B09B609E4563D954BE2E8028320D81B7D412CBF52B9B03A75F2DBBBBD1C3843854E9DAD7996CF2F4D2925B26544CCCD879EA1EB2142CFF3EB280CA438CC576C74E7A838D88438B5122400C97A8ABDB1A711A4EAD355EC3F88A2E779C677AF9994EDB33551A31E3D20770B70EE1D553C39EC4DA2E27E8ECFF5C3A3659300D7F6577D13156BEAAC73E8F627967F217AF75A906DDFB3A5DB4BAA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB5119A0C81A902CEACC49F608552A834225FA72EE860B1D7150CE168B051C942C1F0ECA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F2678FFCB31CF57576ECFCD197662DDF7D3E39C5EFCE805264DFEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF7F0E48E7B97DB3781404D7F26EF74AC3D969D583335D04E1AD3EBDC8179F72D7C05F459966B760F360670765AA9CA1445A1C3F3DC3A4FC5C3EC80F047E061E081F5E849082E5273C93377D15D0AC46E9DE3ED327CCB332ECB5B3ABB6EBD05103AA20B3238A8ABB4EA85D5442656C1CC52C310A3F2D322697735A30058569871F2CACC8F054B32CBF4F322CA5F5FB1F0FB65B74C4CDABAC64DF2DC1E5684F8C616C00D619E5EE56352DAD40D142C815C79DFF45DEBF10476E35D287C11222487D69EE2C8C97E4C7CD2D3725D57D45C9D0054297466EC054A58087AAC31877B45F80EE0B5F02C4F2FDF3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998DD80B9D9183653C4C5106AE5D3BD5837604A5C95CC0493FFB57794DE84535BD71A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E4D86F5770F0AEFF1C1DB8EADEABF435478E46790F8C04AB61AB8F670E65FF0C13D8762B11D337FD66BFD39BF379B12F4ABFE51F69E4655B6D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C395582A0F95A6E3F2F74F37F6196683BBBB36FE47929C1F81B36C52E65B17D8295378F82EE3EAF2DFE1A5CB494106C328FB486CBE41148C920AF7EEF8DA8AD9ED7AE9B89C0B26D4E35B150A49E7CEA122235DEA0A2E70A4313FC2E12054ED17B489B97C3326CFDFDDA021830E3D423B90C73E7BC96F554562874E4E0F063BE627589C7E089720A32C1BD8F792E24D9A41EE70940A06DFC8C1D69DEF08F6E97D847C1014E32808E1F4986A2F4275A5B37D411DCEFCD48A657A996B28081455F480AC620ACB19C8704A432579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C796488C8734C847D1DBA02F62E673B9C3FC1BB7728F8567D9344FDA74482DEBB586A0B56E91605833641EC96B0A4C7E3BC22807EAF1EA9227DD52F865A335A5770C3E287CBD80F3FCB64793F5BDD89524AD35DA8D11B1C1AF59BC0A6D7C832F979E0ACFE623008A0405D61C7A5D6307B378C00120153AC4701F89CE56D22C9E2FCE11924B388BA50A24996495B67C0E9950BA0A8F320F456D4B18ED499F717359186323CC8D4C95ABFD9CAA79BA1F7781B678AAFE4CD2412DC175059E7F592F2C3E8B0D88DC98E9CA1414F35370357F9575E1E461BD205576EB66D70A7AA254773E3B5CEB8976A908ACAEE179F6EA64E3F7612F55CDA7B696A32713ECD4933B90A2C38B5625164714EA720E26CF54A3A73BC9DFCA98B25DFCDF82B77BBBC5B94C7BDD13FDC249DE7D03468F19F4D2872BCED9A14D275B1D2DB4BA68DEC794CBE50605EF7F56368FB2F4B14FD7418F97C43DF64388A46C0FD9D6996F3E1A1FB10D7E495AC794B90C3A7946EAD43988F9ED4BB275AB7832025F9221F3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A89F85FDFDE0A05D02A04225C8F166F61D5A212FBD2A83482E3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6B1E14DE814499DEBB7B1DC9A423D2DD3A01BD832E68494DF15E5A5DA6156FC280";
//        String str = desObj.strEnc(data, key1, key2, key3);
//        System.out.println(str);
        String dec = desObj.strDec(data, key1, key2, key3);
        System.out.println(dec);

//        System.out.println(Des.strEnc("root"));
//        System.out.println(Des.strDec("BA55D020F4DF5EBE24B388BA50A24996495B67C0E9950BA00D28E41BC2D34592D499F717359186323CC8D4C95ABFD9CA3233E97D55652FA44723E8C9B37DAEFDF64528F3B9DDDC895C507682B144934C64B5BE7D6F70F3F02D2421B11B5451A8079D3A964B3D09F5C92BF8CE1ADFF6DA549E4F02087EB7D9D8739C90419FDBCC7281A521EC0FF1B2450690D0CBCB4BD428206F70D78FC02E2C3E5715A865730DFFC8F6E12F4A6EDE205850DF846CDA09A15954F524EEE0F4D1D620018F2AFDD970955C6EFD1386C6A7132EF950AECC4EA0739C8251690A5D08E23D22F08604F3404622D0DF4B8F6BC9F53996C95115B254AFB6FD6AE57DF733CA22F06500F98E3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A88BB293F1BE5899E2A04225C8F166F6110E838E2B15006FBE3405EABD9B2C95B5A12865F7A9C2E07401D7D5DDB6B67B101B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BCFDB1A361AD7E71DB4AAB2E8BAB07B74275792A4777FE54064AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54BDB329079F121A58E4185CF770DD9EC9AEB934CF8BA8FAB5EFF12E2FD850C44390B2B91852014DE74504C31EC7C8112E4B7FE9001C26AE21CC8C1B65536750D66C164B09B36352FEE3FC53E97F2BC97E10A913FF4EEBC52A7F0192975C1DFAC883BF7567D723B902B6D6B3802F5D19E6567A2CE82A06946BD8D6F40CD6B20F2D872D8BBF786F50B090518F1EFA74E61AED09F0A661A75BDAC6A36A4594574554E55FD7632D78D3C1B6D2865DDCD596A31601CB8CC7B6A202B261020F46F20B1049DA46DF7FACD9C816BC9DAA81A65F91EE4C5F93E8AD93F8BB5C181B791117E89C3D6CEC17DDF119AAA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB51192DC5ECF1A569CE8FF608552A834225FA0F8B52CCB2C6093B168B051C942C1F0ECA214E834D633EDB8621F7F566628D769311F0414A9A607DE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F2678FFCB31CF57576EC1843FB790E6FFC6D6031BD5924900B19EDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF17B90F0954C657E3D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C3955CF0BF0AEC98157910D4370ED9650B5F146CB4FB4B5DFB49331E07A35C55D4DE0B69CD15098F33017CD4250D663AD72FD3BCC4EAEA158BF7A7D20FBE7F3A2A2D839179B602EC98044945F94D8EA99A35E9E02BAEDF545E81A9D2ED58AFE37FFD7C2A41C5513DF93FA2A42715610B41F774B6911119F24399A7A2720A40A832AA1BC7920471FD328FA0EA84D5881A387CEE87A560E432715D898CAECA02EEE9D1EC4304CF50137D5D1A4546CE09BD171ED88895D54294C3ACB05AB28772D7EEA6C0C530546E330D886579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C7964885C61BD9455F12B6F2A04225C8F166F614FD981E652937A91E3405EABD9B2C95B5A12865F7A9C2E07401D7D5DDB6B67B101B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6B8804E7E85669D4E4021ABEFD846E37F6D4274D503A77962664AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54BF50F91F020845F0D1404D7F26EF74AC3D969D583335D04E191D398083EBF5B958E957AF13B9C8923473E6EA71909886151D91A99BF8C695BF16233C064507117A78E18F4591C46F7E2A583D4F3A5C2C641A57C644127F02C40BC4CDFA1EAE129CF231FACFE7F68FBD39744FA6E4D7DCB7192E4DC24DE09089A4456CDCD483D38F90BB84247A8D6B706BC559A5FFE971E25E1D0A772887E7069A355DDB7447FF0A847DDFABAC37DCF26DEE301996B0E8D6B777BBCFA99FE62BFF86143D6F939779F6D3C92A74A57107E59DBEAFA0658FA6937043C268465BCA5AAF30583E5023A5580F22213A391A6F3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998AF3E8D1B753745C46CFD160EABC5A1ABF62E673B9C3FC1BB6B689836E2498B4B1A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606ED03E137AB780A913D25BCD21B5EF740DE4D97CF0792843082E5041E2753E03E23D8762B11D337FD66BFD39BF379B12F4EC88DC47B3C36CE79311F0414A9A607DD499F717359186323CC8D4C95ABFD9CAECB1002FCA25B22CB792DB5A6BF0C3CEBB07A38A0D884FD1F8F58CACCF5881A5832877A0491FE3FF92D493D2311E7BDC04F3B3060A3B3EEB7C1FB0FADB9ECFE010CF1E42ACC8324FD40B16A4C214443C0DBE7DC81193E814618FB25B1C7138DAFAF3D3B0ECA42058F3F8FBF5BCFE7F75289E800709194C85D611CC509C98C6D262593F78586209774978E7684A26CF123068B0AEB9DB660424728FB90AAFAD4EA8F4E222C2C69B1C6EFD0E3AD4BB77283D70DDAD099133B9B0A2135613F80399377311BAC887EE5CBEB6A7E3EFBF7E7D3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431AFF67DDE1E771335FF608552A834225FA817586B4D406A8425BF7255C7DB59AF6CA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F267572BE20BCDA1BDEF001BC934F2EA28536CF1A4966DC8895DEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCFF4F2D7BF73D7F317D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C39557FD02BF6FF1484F16B1626A7599E3639227C93BC4C8DAB18F48315D1548E194CED6D4C1009FDAAB540C0D34FEBDD5D1287C0308BBE3767AAD6B31BF8E10F896CA47CF0DF67281B083069DB7CDA4A1FE9F9E7AE8DB7A77B8D8A3102E0F5F81F581166DB46716F8825FC5426E5E788EFDDD2DD1FD440BC7E2EAA066A9C68973509FC673D6E4D89BDD798F2D5F421B84E3D255C7D4DC72DB8CD0BA8340C4BCEC6E62761940D0D129174A815C49B0FC54E5BB53A79176CE4E43E80FC427B7B7E32BAB1E85BD2928E2F14579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C796488720733A5656582F22A04225C8F166F6136C1C6E6FB0ED858E3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BEA75CDBAE4F96367E43BEEC43017129ECEA65E9F193B1EEA64AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54B2AA351944754E03E1404D7F26EF74AC3D969D583335D04E10A78FC94A64D6D53224A1D0C5EFCD5285B333F92829B574FFAA53B02D3F4E0B61E136443510F9D8E1EC7D6EDB828430B80706C0261AB173E12B1E3E9D59830BC899BB8669E39E67593D062736CBAFC4468E39B4AA81839B3C3241DCEE569A23C76B437393FB43AAC91E0CDFBEE1CEA1A9E78A8A546F481DA54049473CE66C812817324B6775201FFAB322082D3CB71F7D20EE02D177522E52A9683817E1BC3031D1A3AF32869038D97E14F6891662253FB8148112F3A734A2C2D5757A06A2F3F89FD63B2EC94C4C7E7D3D302905966BBF3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998AF3E8D1B753745C4826318AA73DF6094F62E673B9C3FC1BB4D985269A9931535A74482DEBB586A0B56E91605833641EC96B0A4C7E3BC22807EAF1EA9227DD52F865A335A5770C3E287CBD80F3FCB64793F5BDD89524AD35DA8D11B1C1AF59BC0A6D7C832F979E0AC4D568E333C0C0DD56493449D0D269D8382C7ECE46A9D5B82E56D22C9E2FCE11924B388BA50A24996495B67C0E9950BA0CF7F130CF5761AE64185CF770DD9EC9AEB934CF8BA8FAB5ED8A8A5B8C4F0DC257A38AFEAE0424AAB86C285E81C460902170A68E833FB5532CCCF78CADD17C2B0F78968F3B94B6A25E26AD0EFC316E44E9B3CB6CE6FB67EC3E28C63D9FDD51E2C03EE1E9C8C7603E42D0C58D3BFCDAA59F55C4A6EDB7DCA19BA7A734A3308F0D8C6504C4E40A9C0A32DBEA8922AD9100D3CB478FF832E2EA418576F3332EADDD5E121DB376715355FAEE005237B469B14E41820D1D088346A05F11281B684F9308F5B495869B78428F02A4A8EF4EAA91C1EB18A78C0473F2FC015D9680EDCD490BEAA6356B684B7C5AA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB51194E3D462287179A9CC5106AE5D3BD5837604A5C95CC0493FF4728AE28FE8C734F1A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E8E32DA3B7E29215FB49B53ACD2A0ED4D974EF431F15988C10A2BB61B73DC2FF93D8762B11D337FD66BFD39BF379B12F4EC88DC47B3C36CE7F9A7296F707CB8BDD499F717359186323CC8D4C95ABFD9CA482CE15070677E9514F11EB950AAC0262A6203301847E8B7A57669372038EFAB22EE9A2E0ED8898055C29727FE20316BA0F302CBEA628355FDE6877E02C750A832CF583B9DB2A17CE1D63DC7F23311F63B2A21EAA0C2C04A21C4FE2CD06F51B5EF3D09333F048CC98982B7EA0FB5E95A2708A5457972A69FCA38E9460162D6A3109792AAAE3E7A2B80E9D3A90698B13AF1AEB081640894E0A44328583AE92AC3DB09278E3C9896E9AA39544D104F9D9BF72FA645BB9471559F16F89C37BAD465AB310CD0339157D9C855FAAE762701743A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A73717E6F786A1BF4F608552A834225FA0F8B52CCB2C6093BE3405EABD9B2C95B5A12865F7A9C2E07401D7D5DDB6B67B101B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BFEF66F5DC09CF6CE3C0409AB012981A64443C53EA62D00BC64AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54B5074656730AF08511404D7F26EF74AC3D969D583335D04E157FC35A20E79CF3436E8587E0FC58DBB4CF4D703725005CD7695ED4BC35EE3D38E72C5435C883195A3B950960B50A83BC9C42BB47E9A7CC81F83E907DE977E9A7A643B1C351F4F2F9C90E8036B9D3176280B843C17EAA61141D3045A8E4A03B7669E258C9B66ACFC6B1A523E227961CCC45096CDF33256C2CCDD04E399EF78E1C0815FB992B67434F5C6109ED730D90CA1D1FD4C34B7EEB3AE3B5B3549C56762063D25FBE49DD4E9E6848CB1B6ECAD9B8C61AABD2DA0A1B3A51BC665B81630A6E1F2388042C994800407FDA4214B8775F3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998AF3E8D1B753745C46B8D7D59992BA3E5F62E673B9C3FC1BB7EDF2D802F29AD991A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E521C295FC671AB741039735BF908A472F3CE20337A3966DB2E5041E2753E03E23D8762B11D337FD66BFD39BF379B12F4EC88DC47B3C36CE7C8734C847D1DBA02D499F717359186323CC8D4C95ABFD9CA7365E1DC9EB2DEAD23FBD27846B4814D144E93C8C57805F810A42609F95E10CB3144527217A7D02BAC3532ED110D47A9AD457FD8A2FD36A86174744C263F313CC9C1E8A4D51D84DB2F1A50F00649D226920B2FBE6AD6E1A529D8DD90B7CA4F9A5282509FAE8DB1B9AA3D18CFBD505105FBA64BC3E757697FC4819262D10CB3365DB79A3772A3DFBDA71735A2574C71D142F38C3884F647B4E4D7C81D2B4EA57D100E7F396CAA65636B214D9A908E3C3302FFF1DC33EFCED38DB53816EE64AF086A82F9577A293A3FA9EF99663EE2903F3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A06F759B7DA04B8DAF608552A834225FAE587B1214FE04201E86D197BA9E586CBCA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F26715083F8A0EB0461453AD2F126FC4D584BAD40CC3ED05088EEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF982366C503C15516D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C39554587278CB2F119DA43F0521CEB71795C7E262B74B02307242312DB6CE24C3F8A50DE58E08B3661E80E30C617B850D71F4BB4D82A9A906AE61EEDAF96F98C3F1DB04543B9F10B83EEB7CF016277C4F0CF5F94DD9C784DD922822C50EDD682A3080C4F52B724D2C37434CE6FC1C156BA39799BC2C4DDE951632FDB50FF1379C481A214C8CB9C308ED2B8A08D04ED5F3E389B6E43D04096E1023104D5F5F47ACD81639BD7900B6064BB54E560ACE353C5FDE0760B21ADD4CCE8C329FFCBEC7E39129DF0C7C60370C108579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C79648828BEE995D7FC518F2A04225C8F166F6128FC45AFF7870E60E3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BD0C4FBF184E1383C7B9BDC440073B35901357948CA60E3F164AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54BC381ED797C2A7ED04185CF770DD9EC9AEB934CF8BA8FAB5E45FDACFB54A0647C7FE3731688A2F37213038EDD7FD03BFE521315C5A492EA3BE6C5431780B8FB1015CF9F04BFF12C96DE63A23454E94CDDC2622716C9EA37ACE10F56E463F499395D4C386E906DCF9DBD6E278E94BE79081F44C9E2078960CA46A539129DD80EB6D71953D45D518D537E7B91BE26DD85B1F85489252AF700F0568D99DEEDC884906D0D74EBB74E5BD5EDB770EA42E2C7CF19B25B080CF3D16848E5C77C235BBD9ACF88B1D963ECAFBC984DAA63A571C330189C1A50A3C1B66ADDE43F3A3180037792AD2FECFC87AA90AA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB5119BA43236822385773F608552A834225FA72EE860B1D7150CE24A362E7792CE61ACA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F267DD1E12F4F3F08B3728D3C33D19813A37200BD46A95F8F2ADEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF07E571D6B33477BF1404D7F26EF74AC3D969D583335D04E10EE7A64FBDD3E55EE1122CCCBFFFA54A89F0877B001DB13BFDD2EC5A55ED95F3668078BEC652F7FB5D44E9E8C1376C721D0D5D4E2BB463576972AFE304B430F094775B6E76F5E12C17E679AEDFE9E24597A74B99058AB384BA190B06081F0CA7B538DD1D49CA399EEAD0DBBF14F9F09F46F7E96426FE9CAD73F3171F5AD90428612C3701E2DCEE777C326E88DBD0778E44F84ADD5A689DBBCB9202138A92BE53C185B2FAA39C23F786FA281CD4C3DBC9DDF4B179AF9A1E43E59DFCCAB9463E004427B4247FE257CA682B638CCB69FC12F3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998598F6C35880B3432C5106AE5D3BD5837604A5C95CC0493FF1365AE824CCD81631A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E4F16FFE29FE0E17256B1A474B6B91688BBD5A9322160E414FAC264972D6B4E2E3D8762B11D337FD66BFD39BF379B12F4ABBB62E12A7B02A5D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C3955C6F1F4CCCF65084C1EF97B74EA6ECAED5939E130514B2161F3D3D504842C2231BEC0AE8B487DEB982A447B41293BB53394F371F1EFE1342ECFF3F75C89CD6FE897730B8A24F301FE5E53AEA245EB1125D2F1E21A5F69E3B8A57C37C08C0C7A70D9AC04E6B397A5E11DFEDB17194809829DF6A733E3CC7AC0D9989C2B3D7ADE28E84269984158510EE20D7AB2824A01D363AB3797915288D0CE23A8EA67B709D5E04C2DC9E9771457BDD0F8FF13C8CDEA5EB5E57A7CD209F226044F39185875E38112F6DEE1F2E121579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C796488826318AA73DF6094F62E673B9C3FC1BB0E3DD6344B19344FA74482DEBB586A0B56E91605833641EC96B0A4C7E3BC22807EAF1EA9227DD52F865A335A5770C3E287CBD80F3FCB64793F5BDD89524AD35DA8D11B1C1AF59BC0A6D7C832F979E0AC36DF30658FDCD29753BDFF63A287DC7421FA8C2F930D5AB9E56D22C9E2FCE11924B388BA50A24996495B67C0E9950BA031A14A1A96F2CAD7D499F717359186323CC8D4C95ABFD9CAEE8791E5B748F838709783B2B8FD5A0EBEC886AE58AC81F642A41AD65BE070377B1B0AB75CA8CBF610B9D9F751264FF029EBCE873C929C6E65091FF3680A7DED07F0A4AAEB497CD39E01A677F01FF44D0695CB04DAB0FEB5CC438EC20F98DDF6A5D2A5B885D0BA746123E7B2003C65CA009BDFC2F1E67CC765F6C17670A9554B92F889ED111F1D786534ED59F2377D38FC8300586AAD17948C5AE4D48937A6E560AC2BBD2EFDD3AD573295C51DA056CC53444B958C18B8F81F0FBE3D45EA56A955D6FE7377E6C8948129428622D55C163A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A6601EF49D49B17A12A04225C8F166F61462EC305C6501E1CE3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6BF6AD2BB40CC0365F8DACD914DE7EF5429C6CFD5802A7195C64AA8406B99CD92DE332CC6EFE1D0E8520C284106B2DF54B706302C843FD23E94185CF770DD9EC9AEB934CF8BA8FAB5EDE38FFCA39356E1B84AD0F6D04564D939B0BD7B898D24666441134F9ADA8BF35EB45EABF21494FB7128FD53885B98047C0E2E9F6230E7E4D8B09B609E4563D954BE2E8028320D81B7D412CBF52B9B03A75F2DBBBBD1C3843854E9DAD7996CF2F4D2925B26544CCCD879EA1EB2142CFF3EB280CA438CC576C74E7A838D88438B5122400C97A8ABDB1A711A4EAD355EC3F88A2E779C677AF9994EDB33551A31E3D20770B70EE1D553C39EC4DA2E27E8ECFF5C3A3659300D7F6577D13156BEAAC73E8F627967F217AF75A906DDFB3A5DB4BAA56A058F9F8105EA6E11C825B017E0E51A665EDEFDB5119A0C81A902CEACC49F608552A834225FA72EE860B1D7150CE168B051C942C1F0ECA214E834D633EDB8621F7F566628D766CFD160EABC5A1ABE0D6FA6F48AAC1FA77C10F22C1C650D2C82C8267169AEEEA016A60E6436223C57FA4DCFA55F0F2678FFCB31CF57576ECFCD197662DDF7D3E39C5EFCE805264DFEDED0658611A59CAD491F75565C3ED3F8F444D0CDDB30BCF7F0E48E7B97DB3781404D7F26EF74AC3D969D583335D04E1AD3EBDC8179F72D7C05F459966B760F360670765AA9CA1445A1C3F3DC3A4FC5C3EC80F047E061E081F5E849082E5273C93377D15D0AC46E9DE3ED327CCB332ECB5B3ABB6EBD05103AA20B3238A8ABB4EA85D5442656C1CC52C310A3F2D322697735A30058569871F2CACC8F054B32CBF4F322CA5F5FB1F0FB65B74C4CDABAC64DF2DC1E5684F8C616C00D619E5EE56352DAD40D142C815C79DFF45DEBF10476E35D287C11222487D69EE2C8C97E4C7CD2D3725D57D45C9D0054297466EC054A58087AAC31877B45F80EE0B5F02C4F2FDF3310A645860DECE3889EA6B9D206ED0F7E615D679BFD998DD80B9D9183653C4C5106AE5D3BD5837604A5C95CC0493FFB57794DE84535BD71A68CCF4BC98F515E5556FFB80B9CACF1500ECC22DCF75B181F572BF039813F3EDDC1F499898A43B279DDDB4992595CDC5DBF30BECF22B7678DDB927CCC2606E4D86F5770F0AEFF1C1DB8EADEABF435478E46790F8C04AB61AB8F670E65FF0C13D8762B11D337FD66BFD39BF379B12F4ABFE51F69E4655B6D769EB9EAF6BE37CFF3FD6B0CECD51BE7D0624B96F4C395582A0F95A6E3F2F74F37F6196683BBBB36FE47929C1F81B36C52E65B17D8295378F82EE3EAF2DFE1A5CB494106C328FB486CBE41148C920AF7EEF8DA8AD9ED7AE9B89C0B26D4E35B150A49E7CEA122235DEA0A2E70A4313FC2E12054ED17B489B97C3326CFDFDDA021830E3D423B90C73E7BC96F554562874E4E0F063BE627589C7E089720A32C1BD8F792E24D9A41EE70940A06DFC8C1D69DEF08F6E97D847C1014E32808E1F4986A2F4275A5B37D411DCEFCD48A657A996B28081455F480AC620ACB19C8704A432579F2A373A5C75B08AB98FEFA1192DF6B18895557D4CE1F63A1C3E067C796488C8734C847D1DBA02F62E673B9C3FC1BB7728F8567D9344FDA74482DEBB586A0B56E91605833641EC96B0A4C7E3BC22807EAF1EA9227DD52F865A335A5770C3E287CBD80F3FCB64793F5BDD89524AD35DA8D11B1C1AF59BC0A6D7C832F979E0ACFE623008A0405D61C7A5D6307B378C00120153AC4701F89CE56D22C9E2FCE11924B388BA50A24996495B67C0E9950BA0A8F320F456D4B18ED499F717359186323CC8D4C95ABFD9CAA79BA1F7781B678AAFE4CD2412DC175059E7F592F2C3E8B0D88DC98E9CA1414F35370357F9575E1E461BD205576EB66D70A7AA254773E3B5CEB8976A908ACAEE179F6EA64E3F7612F55CDA7B696A32713ECD4933B90A2C38B5625164714EA720E26CF54A3A73BC9DFCA98B25DFCDF82B77BBBC5B94C7BDD13FDC249DE7D03468F19F4D2872BCED9A14D275B1D2DB4BA68DEC794CBE50605EF7F56368FB2F4B14FD7418F97C43DF64388A46C0FD9D6996F3E1A1FB10D7E495AC794B90C3A7946EAD43988F9ED4BB275AB7832025F9221F3A1C3E067C7964886BFD39BF379B12F46DC0CC078FC8431A89F85FDFDE0A05D02A04225C8F166F61D5A212FBD2A83482E3405EABD9B2C95B5A12865F7A9C2E073F5BDD89524AD35D01B1C41381FA6E4468AC0F3C024C92E2762705A04D059129A6E11C825B017E0EE443F49AC96F1ABEA1C876D5015FFA6B1E14DE814499DEBB7B1DC9A423D2DD3A01BD832E68494DF15E5A5DA6156FC280"));
    }

    public static String strEnc(String data){
        return strEnc(data, DEFAULT_DES_KEY, null, null);
    }

    /**
     * @return
     * @方法名称: strEnc
     * @实现功能: DES加密/解密
     * @params
     * @create by peijd at 2017/5/24 13:57
     */
    public static String strEnc(String data, String firstKey, String secondKey, String thirdKey) {
        int leng = data.length();
        String encData = "";
        firstKey = DcStringUtils.isBlank(firstKey)? DEFAULT_DES_KEY :firstKey;
        List firstKeyBt = null, secondKeyBt = null, thirdKeyBt = null;
        int firstLength = 0, secondLength = 0, thirdLength = 0;
        if (firstKey != null && firstKey != "") {
            firstKeyBt = getKeyBytes(firstKey);
            firstLength = firstKeyBt.size();
        }
        if (secondKey != null && secondKey != "") {
            secondKeyBt = getKeyBytes(secondKey);
            secondLength = secondKeyBt.size();
        }
        if (thirdKey != null && thirdKey != "") {
            thirdKeyBt = getKeyBytes(thirdKey);
            thirdLength = thirdKeyBt.size();
        }

        if (leng > 0) {
            if (leng < 4) {
                int[] bt = strToBt(data);
                int[] encByte = null;
                if (firstKey != null && firstKey != "" && secondKey != null
                        && secondKey != "" && thirdKey != null
                        && thirdKey != "") {
                    int[] tempBt;
                    int x, y, z;
                    tempBt = bt;
                    for (x = 0; x < firstLength; x++) {
                        tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                    }
                    for (y = 0; y < secondLength; y++) {
                        tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                    }
                    for (z = 0; z < thirdLength; z++) {
                        tempBt = enc(tempBt, (int[]) thirdKeyBt.get(z));
                    }
                    encByte = tempBt;
                } else {
                    if (firstKey != null && firstKey != "" && secondKey != null
                            && secondKey != "") {
                        int[] tempBt;
                        int x, y;
                        tempBt = bt;
                        for (x = 0; x < firstLength; x++) {
                            tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                        }
                        for (y = 0; y < secondLength; y++) {
                            tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                        }
                        encByte = tempBt;
                    } else {
                        if (firstKey != null && firstKey != "") {
                            int[] tempBt;
                            int x = 0;
                            tempBt = bt;
                            for (x = 0; x < firstLength; x++) {
                                tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                            }
                            encByte = tempBt;
                        }
                    }
                }
                encData = bt64ToHex(encByte);
            } else {
                int iterator = (leng / 4);
                int remainder = leng % 4;
                int i = 0;
                for (i = 0; i < iterator; i++) {
                    String tempData = data.substring(i * 4 + 0, i * 4 + 4);
                    int[] tempByte = strToBt(tempData);
                    int[] encByte = null;
                    if (firstKey != null && firstKey != "" && secondKey != null
                            && secondKey != "" && thirdKey != null
                            && thirdKey != "") {
                        int[] tempBt;
                        int x, y, z;
                        tempBt = tempByte;
                        for (x = 0; x < firstLength; x++) {
                            tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                        }
                        for (y = 0; y < secondLength; y++) {
                            tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                        }
                        for (z = 0; z < thirdLength; z++) {
                            tempBt = enc(tempBt, (int[]) thirdKeyBt.get(z));
                        }
                        encByte = tempBt;
                    } else {
                        if (firstKey != null && firstKey != ""
                                && secondKey != null && secondKey != "") {
                            int[] tempBt;
                            int x, y;
                            tempBt = tempByte;
                            for (x = 0; x < firstLength; x++) {
                                tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                            }
                            for (y = 0; y < secondLength; y++) {
                                tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                            }
                            encByte = tempBt;
                        } else {
                            if (firstKey != null && firstKey != "") {
                                int[] tempBt;
                                int x;
                                tempBt = tempByte;
                                for (x = 0; x < firstLength; x++) {
                                    tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                                }
                                encByte = tempBt;
                            }
                        }
                    }
                    encData += bt64ToHex(encByte);
                }
                if (remainder > 0) {
                    String remainderData = data.substring(iterator * 4 + 0, leng);
                    int[] tempByte = strToBt(remainderData);
                    int[] encByte = null;
                    if (firstKey != null && firstKey != "" && secondKey != null && secondKey != "" && thirdKey != null && thirdKey != "") {
                        int[] tempBt;
                        int x, y, z;
                        tempBt = tempByte;
                        for (x = 0; x < firstLength; x++) {
                            tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                        }
                        for (y = 0; y < secondLength; y++) {
                            tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                        }
                        for (z = 0; z < thirdLength; z++) {
                            tempBt = enc(tempBt, (int[]) thirdKeyBt.get(z));
                        }
                        encByte = tempBt;
                    } else {
                        if (firstKey != null && firstKey != "" && secondKey != null && secondKey != "") {
                            int[] tempBt;
                            int x, y;
                            tempBt = tempByte;
                            for (x = 0; x < firstLength; x++) {
                                tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                            }
                            for (y = 0; y < secondLength; y++) {
                                tempBt = enc(tempBt, (int[]) secondKeyBt.get(y));
                            }
                            encByte = tempBt;
                        } else {
                            if (firstKey != null && firstKey != "") {
                                int[] tempBt;
                                int x;
                                tempBt = tempByte;
                                for (x = 0; x < firstLength; x++) {
                                    tempBt = enc(tempBt, (int[]) firstKeyBt.get(x));
                                }
                                encByte = tempBt;
                            }
                        }
                    }
                    encData += bt64ToHex(encByte);
                }
            }
        }
        return encData;
    }

    public static String strDec(String data){
        return strDec(data, Des.DEFAULT_DES_KEY, null, null);
    }



    /**
     * @方法名称: strDec
     * @实现功能: 解密数据
     * @params  [data, firstKey, secondKey, thirdKey]
     * @return  java.lang.String
     * @create by peijd at 2017/5/24 14:03
     */
    public static String strDec(String data, String firstKey, String secondKey, String thirdKey) {
        int leng = data.length();
        String decStr = "";
        firstKey = DcStringUtils.isBlank(firstKey)? DEFAULT_DES_KEY :firstKey;
        List firstKeyBt = null, secondKeyBt = null, thirdKeyBt = null;
        int firstLength = 0, secondLength = 0, thirdLength = 0;
        if (firstKey != null && firstKey != "") {
            firstKeyBt = getKeyBytes(firstKey);
            firstLength = firstKeyBt.size();
        }
        if (secondKey != null && secondKey != "") {
            secondKeyBt = getKeyBytes(secondKey);
            secondLength = secondKeyBt.size();
        }
        if (thirdKey != null && thirdKey != "") {
            thirdKeyBt = getKeyBytes(thirdKey);
            thirdLength = thirdKeyBt.size();
        }

        int iterator = leng / 16;
        int i = 0;
        for (i = 0; i < iterator; i++) {
            String tempData = data.substring(i * 16 + 0, i * 16 + 16);
            String strByte = hexToBt64(tempData);
            int[] intByte = new int[64];
            int j = 0;
            for (j = 0; j < 64; j++) {
                intByte[j] = Integer.parseInt(strByte.substring(j, j + 1));
            }
            int[] decByte = null;
            if (firstKey != null && firstKey != "" && secondKey != null && secondKey != "" && thirdKey != null && thirdKey != "") {
                int[] tempBt;
                int x, y, z;
                tempBt = intByte;
                for (x = thirdLength - 1; x >= 0; x--) {
                    tempBt = dec(tempBt, (int[]) thirdKeyBt.get(x));
                }
                for (y = secondLength - 1; y >= 0; y--) {
                    tempBt = dec(tempBt, (int[]) secondKeyBt.get(y));
                }
                for (z = firstLength - 1; z >= 0; z--) {
                    tempBt = dec(tempBt, (int[]) firstKeyBt.get(z));
                }
                decByte = tempBt;
            } else {
                if (firstKey != null && firstKey != "" && secondKey != null  && secondKey != "") {
                    int[] tempBt;
                    int x, y, z;
                    tempBt = intByte;
                    for (x = secondLength - 1; x >= 0; x--) {
                        tempBt = dec(tempBt, (int[]) secondKeyBt.get(x));
                    }
                    for (y = firstLength - 1; y >= 0; y--) {
                        tempBt = dec(tempBt, (int[]) firstKeyBt.get(y));
                    }
                    decByte = tempBt;
                } else {
                    if (firstKey != null && firstKey != "") {
                        int[] tempBt;
                        int x, y, z;
                        tempBt = intByte;
                        for (x = firstLength - 1; x >= 0; x--) {
                            tempBt = dec(tempBt, (int[]) firstKeyBt.get(x));
                        }
                        decByte = tempBt;
                    }
                }
            }
            decStr += byteToString(decByte);
        }
        return decStr;
    }

    /**
     * @方法名称: getKeyBytes
     * @实现功能: 字符串转换为字节列表
     * @params  [key]
     * @return  java.util.List
     * @create by peijd at 2017/5/24 14:06
     */
    public static List getKeyBytes(String key) {
        List keyBytes = new ArrayList();
        int leng = key.length();
        int iterator = (leng / 4);
        int remainder = leng % 4;
        int i = 0;
        for (i = 0; i < iterator; i++) {
            keyBytes.add(i, strToBt(key.substring(i * 4 + 0, i * 4 + 4)));
        }
        if (remainder > 0) {
            // keyBytes[i] = strToBt(key.substring(i*4+0,leng));
            keyBytes.add(i, strToBt(key.substring(i * 4 + 0, leng)));
        }
        return keyBytes;
    }

    /**
     * chang the string(it's length <= 4) into the bit array
     *
     * return bit array(it's length = 64)
     **/
    public  static int[] strToBt(String str) {
        int leng = str.length();
        int[] bt = new int[64];
        if (leng < 4) {
            int i = 0, j = 0, p = 0, q = 0;
            for (i = 0; i < leng; i++) {
                int k = str.charAt(i);
                for (j = 0; j < 16; j++) {
                    int pow = 1, m = 0;
                    for (m = 15; m > j; m--) {
                        pow *= 2;
                    }
                    // bt.set(16*i+j,""+(k/pow)%2));
                    bt[16 * i + j] = (k / pow) % 2;
                }
            }
            for (p = leng; p < 4; p++) {
                int k = 0;
                for (q = 0; q < 16; q++) {
                    int pow = 1, m = 0;
                    for (m = 15; m > q; m--) {
                        pow *= 2;
                    }
                    // bt[16*p+q]=parseInt(k/pow)%2;
                    // bt.add(16*p+q,""+((k/pow)%2));
                    bt[16 * p + q] = (k / pow) % 2;
                }
            }
        } else {
            for (int i = 0; i < 4; i++) {
                int k = str.charAt(i);
                for (int j = 0; j < 16; j++) {
                    int pow = 1;
                    for (int m = 15; m > j; m--) {
                        pow *= 2;
                    }
                    // bt[16*i+j]=parseInt(k/pow)%2;
                    // bt.add(16*i+j,""+((k/pow)%2));
                    bt[16 * i + j] = (k / pow) % 2;
                }
            }
        }
        return bt;
    }

    /*
     * chang the bit(it's length = 4) into the hex
     *
     * return hex
     */
    public static String bt4ToHex(String binary) {
        String hex = "";
        if (binary.equalsIgnoreCase("0000")) {
            hex = "0";
        } else if (binary.equalsIgnoreCase("0001")) {
            hex = "1";
        } else if (binary.equalsIgnoreCase("0010")) {
            hex = "2";
        } else if (binary.equalsIgnoreCase("0011")) {
            hex = "3";
        } else if (binary.equalsIgnoreCase("0100")) {
            hex = "4";
        } else if (binary.equalsIgnoreCase("0101")) {
            hex = "5";
        } else if (binary.equalsIgnoreCase("0110")) {
            hex = "6";
        } else if (binary.equalsIgnoreCase("0111")) {
            hex = "7";
        } else if (binary.equalsIgnoreCase("1000")) {
            hex = "8";
        } else if (binary.equalsIgnoreCase("1001")) {
            hex = "9";
        } else if (binary.equalsIgnoreCase("1010")) {
            hex = "A";
        } else if (binary.equalsIgnoreCase("1011")) {
            hex = "B";
        } else if (binary.equalsIgnoreCase("1100")) {
            hex = "C";
        } else if (binary.equalsIgnoreCase("1101")) {
            hex = "D";
        } else if (binary.equalsIgnoreCase("1110")) {
            hex = "E";
        } else if (binary.equalsIgnoreCase("1111")) {
            hex = "F";
        }

        return hex;
    }

    /*
     * chang the hex into the bit(it's length = 4)
     *
     * return the bit(it's length = 4)
     */
    public static String hexToBt4(String hex) {
        String binary = "";
        if (hex.equalsIgnoreCase("0")) {
            binary = "0000";
        } else if (hex.equalsIgnoreCase("1")) {
            binary = "0001";
        }
        if (hex.equalsIgnoreCase("2")) {
            binary = "0010";
        }
        if (hex.equalsIgnoreCase("3")) {
            binary = "0011";
        }
        if (hex.equalsIgnoreCase("4")) {
            binary = "0100";
        }
        if (hex.equalsIgnoreCase("5")) {
            binary = "0101";
        }
        if (hex.equalsIgnoreCase("6")) {
            binary = "0110";
        }
        if (hex.equalsIgnoreCase("7")) {
            binary = "0111";
        }
        if (hex.equalsIgnoreCase("8")) {
            binary = "1000";
        }
        if (hex.equalsIgnoreCase("9")) {
            binary = "1001";
        }
        if (hex.equalsIgnoreCase("A")) {
            binary = "1010";
        }
        if (hex.equalsIgnoreCase("B")) {
            binary = "1011";
        }
        if (hex.equalsIgnoreCase("C")) {
            binary = "1100";
        }
        if (hex.equalsIgnoreCase("D")) {
            binary = "1101";
        }
        if (hex.equalsIgnoreCase("E")) {
            binary = "1110";
        }
        if (hex.equalsIgnoreCase("F")) {
            binary = "1111";
        }
        return binary;
    }

    /*
     * chang the bit(it's length = 64) into the string
     *
     * return string
     */
    public static String byteToString(int[] byteData) {
        String str = "";
        for (int i = 0; i < 4; i++) {
            int count = 0;
            for (int j = 0; j < 16; j++) {
                int pow = 1;
                for (int m = 15; m > j; m--) {
                    pow *= 2;
                }
                count += byteData[16 * i + j] * pow;
            }
            if (count != 0) {
                str += "" + (char) (count);
            }
        }
        return str;
    }

    public static String bt64ToHex(int[] byteData) {
        String hex = "";
        for (int i = 0; i < 16; i++) {
            String bt = "";
            for (int j = 0; j < 4; j++) {
                bt += byteData[i * 4 + j];
            }
            hex += bt4ToHex(bt);
        }
        return hex;
    }

    public  static String hexToBt64(String hex) {
        String binary = "";
        for (int i = 0; i < 16; i++) {
            binary += hexToBt4(hex.substring(i, i + 1));
        }
        return binary;
    }

    /*
     * the 64 bit des core arithmetic
     */

    public  static int[] enc(int[] dataByte, int[] keyByte) {
        int[][] keys = generateKeys(keyByte);
        int[] ipByte = initPermute(dataByte);
        int[] ipLeft = new int[32];
        int[] ipRight = new int[32];
        int[] tempLeft = new int[32];
        int i = 0, j = 0, k = 0, m = 0, n = 0;
        for (k = 0; k < 32; k++) {
            ipLeft[k] = ipByte[k];
            ipRight[k] = ipByte[32 + k];
        }
        for (i = 0; i < 16; i++) {
            for (j = 0; j < 32; j++) {
                tempLeft[j] = ipLeft[j];
                ipLeft[j] = ipRight[j];
            }
            int[] key = new int[48];
            for (m = 0; m < 48; m++) {
                key[m] = keys[i][m];
            }
            int[] tempRight = xor(pPermute(sBoxPermute(xor(
                    expandPermute(ipRight), key))), tempLeft);
            for (n = 0; n < 32; n++) {
                ipRight[n] = tempRight[n];
            }

        }

        int[] finalData = new int[64];
        for (i = 0; i < 32; i++) {
            finalData[i] = ipRight[i];
            finalData[32 + i] = ipLeft[i];
        }
        return finallyPermute(finalData);
    }

    public static  int[] dec(int[] dataByte, int[] keyByte) {
        int[][] keys = generateKeys(keyByte);
        int[] ipByte = initPermute(dataByte);
        int[] ipLeft = new int[32];
        int[] ipRight = new int[32];
        int[] tempLeft = new int[32];
        int i = 0, j = 0, k = 0, m = 0, n = 0;
        for (k = 0; k < 32; k++) {
            ipLeft[k] = ipByte[k];
            ipRight[k] = ipByte[32 + k];
        }
        for (i = 15; i >= 0; i--) {
            for (j = 0; j < 32; j++) {
                tempLeft[j] = ipLeft[j];
                ipLeft[j] = ipRight[j];
            }
            int[] key = new int[48];
            for (m = 0; m < 48; m++) {
                key[m] = keys[i][m];
            }

            int[] tempRight = xor(pPermute(sBoxPermute(xor(
                    expandPermute(ipRight), key))), tempLeft);
            for (n = 0; n < 32; n++) {
                ipRight[n] = tempRight[n];
            }
        }

        int[] finalData = new int[64];
        for (i = 0; i < 32; i++) {
            finalData[i] = ipRight[i];
            finalData[32 + i] = ipLeft[i];
        }
        return finallyPermute(finalData);
    }

    public static  int[] initPermute(int[] originalData) {
        int[] ipByte = new int[64];
        int i = 0, m = 1, n = 0, j, k;
        for (i = 0, m = 1, n = 0; i < 4; i++, m += 2, n += 2) {
            for (j = 7, k = 0; j >= 0; j--, k++) {
                ipByte[i * 8 + k] = originalData[j * 8 + m];
                ipByte[i * 8 + k + 32] = originalData[j * 8 + n];
            }
        }
        return ipByte;
    }

    public static  int[] expandPermute(int[] rightData) {
        int[] epByte = new int[48];
        int i, j;
        for (i = 0; i < 8; i++) {
            if (i == 0) {
                epByte[i * 6 + 0] = rightData[31];
            } else {
                epByte[i * 6 + 0] = rightData[i * 4 - 1];
            }
            epByte[i * 6 + 1] = rightData[i * 4 + 0];
            epByte[i * 6 + 2] = rightData[i * 4 + 1];
            epByte[i * 6 + 3] = rightData[i * 4 + 2];
            epByte[i * 6 + 4] = rightData[i * 4 + 3];
            if (i == 7) {
                epByte[i * 6 + 5] = rightData[0];
            } else {
                epByte[i * 6 + 5] = rightData[i * 4 + 4];
            }
        }
        return epByte;
    }

    public static  int[] xor(int[] byteOne, int[] byteTwo) {
        // var xorByte = new Array(byteOne.length);
        // for(int i = 0;i < byteOne.length; i ++){
        // xorByte[i] = byteOne[i] ^ byteTwo[i];
        // }
        // return xorByte;
        int[] xorByte = new int[byteOne.length];
        for (int i = 0; i < byteOne.length; i++) {
            xorByte[i] = byteOne[i] ^ byteTwo[i];
        }
        return xorByte;
    }

    public  static int[] sBoxPermute(int[] expandByte) {

        // var sBoxByte = new Array(32);
        int[] sBoxByte = new int[32];
        String binary = "";
        int[][] s1 = {
                {14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},
                {0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},
                {4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},
                {15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13}};

        /* Table - s2 */
        int[][] s2 = {
                {15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},
                {3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},
                {0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},
                {13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9}};

        /* Table - s3 */
        int[][] s3 = {
                {10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},
                {13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},
                {13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},
                {1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12}};
        /* Table - s4 */
        int[][] s4 = {
                {7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},
                {13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},
                {10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},
                {3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14}};

        /* Table - s5 */
        int[][] s5 = {
                {2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},
                {14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},
                {4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},
                {11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3}};

        /* Table - s6 */
        int[][] s6 = {
                {12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},
                {10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},
                {9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},
                {4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13}};

        /* Table - s7 */
        int[][] s7 = {
                {4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},
                {13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},
                {1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},
                {6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12}};

        /* Table - s8 */
        int[][] s8 = {
                {13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},
                {1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},
                {7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},
                {2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11}};

        for (int m = 0; m < 8; m++) {
            int i = 0, j = 0;
            i = expandByte[m * 6 + 0] * 2 + expandByte[m * 6 + 5];
            j = expandByte[m * 6 + 1] * 2 * 2 * 2 + expandByte[m * 6 + 2] * 2
                    * 2 + expandByte[m * 6 + 3] * 2 + expandByte[m * 6 + 4];
            switch (m) {
                case 0:
                    binary = getBoxBinary(s1[i][j]);
                    break;
                case 1:
                    binary = getBoxBinary(s2[i][j]);
                    break;
                case 2:
                    binary = getBoxBinary(s3[i][j]);
                    break;
                case 3:
                    binary = getBoxBinary(s4[i][j]);
                    break;
                case 4:
                    binary = getBoxBinary(s5[i][j]);
                    break;
                case 5:
                    binary = getBoxBinary(s6[i][j]);
                    break;
                case 6:
                    binary = getBoxBinary(s7[i][j]);
                    break;
                case 7:
                    binary = getBoxBinary(s8[i][j]);
                    break;
            }
            sBoxByte[m * 4 + 0] = Integer.parseInt(binary.substring(0, 1));
            sBoxByte[m * 4 + 1] = Integer.parseInt(binary.substring(1, 2));
            sBoxByte[m * 4 + 2] = Integer.parseInt(binary.substring(2, 3));
            sBoxByte[m * 4 + 3] = Integer.parseInt(binary.substring(3, 4));
        }
        return sBoxByte;
    }

    public  static int[] pPermute(int[] sBoxByte) {
        int[] pBoxPermute = new int[32];
        pBoxPermute[0] = sBoxByte[15];
        pBoxPermute[1] = sBoxByte[6];
        pBoxPermute[2] = sBoxByte[19];
        pBoxPermute[3] = sBoxByte[20];
        pBoxPermute[4] = sBoxByte[28];
        pBoxPermute[5] = sBoxByte[11];
        pBoxPermute[6] = sBoxByte[27];
        pBoxPermute[7] = sBoxByte[16];
        pBoxPermute[8] = sBoxByte[0];
        pBoxPermute[9] = sBoxByte[14];
        pBoxPermute[10] = sBoxByte[22];
        pBoxPermute[11] = sBoxByte[25];
        pBoxPermute[12] = sBoxByte[4];
        pBoxPermute[13] = sBoxByte[17];
        pBoxPermute[14] = sBoxByte[30];
        pBoxPermute[15] = sBoxByte[9];
        pBoxPermute[16] = sBoxByte[1];
        pBoxPermute[17] = sBoxByte[7];
        pBoxPermute[18] = sBoxByte[23];
        pBoxPermute[19] = sBoxByte[13];
        pBoxPermute[20] = sBoxByte[31];
        pBoxPermute[21] = sBoxByte[26];
        pBoxPermute[22] = sBoxByte[2];
        pBoxPermute[23] = sBoxByte[8];
        pBoxPermute[24] = sBoxByte[18];
        pBoxPermute[25] = sBoxByte[12];
        pBoxPermute[26] = sBoxByte[29];
        pBoxPermute[27] = sBoxByte[5];
        pBoxPermute[28] = sBoxByte[21];
        pBoxPermute[29] = sBoxByte[10];
        pBoxPermute[30] = sBoxByte[3];
        pBoxPermute[31] = sBoxByte[24];
        return pBoxPermute;
    }

    public static  int[] finallyPermute(int[] endByte) {
        int[] fpByte = new int[64];
        fpByte[0] = endByte[39];
        fpByte[1] = endByte[7];
        fpByte[2] = endByte[47];
        fpByte[3] = endByte[15];
        fpByte[4] = endByte[55];
        fpByte[5] = endByte[23];
        fpByte[6] = endByte[63];
        fpByte[7] = endByte[31];
        fpByte[8] = endByte[38];
        fpByte[9] = endByte[6];
        fpByte[10] = endByte[46];
        fpByte[11] = endByte[14];
        fpByte[12] = endByte[54];
        fpByte[13] = endByte[22];
        fpByte[14] = endByte[62];
        fpByte[15] = endByte[30];
        fpByte[16] = endByte[37];
        fpByte[17] = endByte[5];
        fpByte[18] = endByte[45];
        fpByte[19] = endByte[13];
        fpByte[20] = endByte[53];
        fpByte[21] = endByte[21];
        fpByte[22] = endByte[61];
        fpByte[23] = endByte[29];
        fpByte[24] = endByte[36];
        fpByte[25] = endByte[4];
        fpByte[26] = endByte[44];
        fpByte[27] = endByte[12];
        fpByte[28] = endByte[52];
        fpByte[29] = endByte[20];
        fpByte[30] = endByte[60];
        fpByte[31] = endByte[28];
        fpByte[32] = endByte[35];
        fpByte[33] = endByte[3];
        fpByte[34] = endByte[43];
        fpByte[35] = endByte[11];
        fpByte[36] = endByte[51];
        fpByte[37] = endByte[19];
        fpByte[38] = endByte[59];
        fpByte[39] = endByte[27];
        fpByte[40] = endByte[34];
        fpByte[41] = endByte[2];
        fpByte[42] = endByte[42];
        fpByte[43] = endByte[10];
        fpByte[44] = endByte[50];
        fpByte[45] = endByte[18];
        fpByte[46] = endByte[58];
        fpByte[47] = endByte[26];
        fpByte[48] = endByte[33];
        fpByte[49] = endByte[1];
        fpByte[50] = endByte[41];
        fpByte[51] = endByte[9];
        fpByte[52] = endByte[49];
        fpByte[53] = endByte[17];
        fpByte[54] = endByte[57];
        fpByte[55] = endByte[25];
        fpByte[56] = endByte[32];
        fpByte[57] = endByte[0];
        fpByte[58] = endByte[40];
        fpByte[59] = endByte[8];
        fpByte[60] = endByte[48];
        fpByte[61] = endByte[16];
        fpByte[62] = endByte[56];
        fpByte[63] = endByte[24];
        return fpByte;
    }

    public static String getBoxBinary(int i) {
        String binary = "";
        switch (i) {
            case 0:
                binary = "0000";
                break;
            case 1:
                binary = "0001";
                break;
            case 2:
                binary = "0010";
                break;
            case 3:
                binary = "0011";
                break;
            case 4:
                binary = "0100";
                break;
            case 5:
                binary = "0101";
                break;
            case 6:
                binary = "0110";
                break;
            case 7:
                binary = "0111";
                break;
            case 8:
                binary = "1000";
                break;
            case 9:
                binary = "1001";
                break;
            case 10:
                binary = "1010";
                break;
            case 11:
                binary = "1011";
                break;
            case 12:
                binary = "1100";
                break;
            case 13:
                binary = "1101";
                break;
            case 14:
                binary = "1110";
                break;
            case 15:
                binary = "1111";
                break;
        }
        return binary;
    }

    /*
     * generate 16 keys for xor
     *
     */
    public static  int[][] generateKeys(int[] keyByte) {
        int[] key = new int[56];
        int[][] keys = new int[16][48];

        // keys[ 0] = new Array();
        // keys[ 1] = new Array();
        // keys[ 2] = new Array();
        // keys[ 3] = new Array();
        // keys[ 4] = new Array();
        // keys[ 5] = new Array();
        // keys[ 6] = new Array();
        // keys[ 7] = new Array();
        // keys[ 8] = new Array();
        // keys[ 9] = new Array();
        // keys[10] = new Array();
        // keys[11] = new Array();
        // keys[12] = new Array();
        // keys[13] = new Array();
        // keys[14] = new Array();
        // keys[15] = new Array();
        int[] loop = new int[]{1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1};

        for (int i = 0; i < 7; i++) {
            for (int j = 0, k = 7; j < 8; j++, k--) {
                key[i * 8 + j] = keyByte[8 * k + i];
            }
        }

        int i = 0;
        for (i = 0; i < 16; i++) {
            int tempLeft = 0;
            int tempRight = 0;
            for (int j = 0; j < loop[i]; j++) {
                tempLeft = key[0];
                tempRight = key[28];
                for (int k = 0; k < 27; k++) {
                    key[k] = key[k + 1];
                    key[28 + k] = key[29 + k];
                }
                key[27] = tempLeft;
                key[55] = tempRight;
            }
            // var tempKey = new Array(48);
            int[] tempKey = new int[48];
            tempKey[0] = key[13];
            tempKey[1] = key[16];
            tempKey[2] = key[10];
            tempKey[3] = key[23];
            tempKey[4] = key[0];
            tempKey[5] = key[4];
            tempKey[6] = key[2];
            tempKey[7] = key[27];
            tempKey[8] = key[14];
            tempKey[9] = key[5];
            tempKey[10] = key[20];
            tempKey[11] = key[9];
            tempKey[12] = key[22];
            tempKey[13] = key[18];
            tempKey[14] = key[11];
            tempKey[15] = key[3];
            tempKey[16] = key[25];
            tempKey[17] = key[7];
            tempKey[18] = key[15];
            tempKey[19] = key[6];
            tempKey[20] = key[26];
            tempKey[21] = key[19];
            tempKey[22] = key[12];
            tempKey[23] = key[1];
            tempKey[24] = key[40];
            tempKey[25] = key[51];
            tempKey[26] = key[30];
            tempKey[27] = key[36];
            tempKey[28] = key[46];
            tempKey[29] = key[54];
            tempKey[30] = key[29];
            tempKey[31] = key[39];
            tempKey[32] = key[50];
            tempKey[33] = key[44];
            tempKey[34] = key[32];
            tempKey[35] = key[47];
            tempKey[36] = key[43];
            tempKey[37] = key[48];
            tempKey[38] = key[38];
            tempKey[39] = key[55];
            tempKey[40] = key[33];
            tempKey[41] = key[52];
            tempKey[42] = key[45];
            tempKey[43] = key[41];
            tempKey[44] = key[49];
            tempKey[45] = key[35];
            tempKey[46] = key[28];
            tempKey[47] = key[31];
            int m;
            switch (i) {
                case 0:
                    for (m = 0; m < 48; m++) {
                        keys[0][m] = tempKey[m];
                    }
                    break;
                case 1:
                    for (m = 0; m < 48; m++) {
                        keys[1][m] = tempKey[m];
                    }
                    break;
                case 2:
                    for (m = 0; m < 48; m++) {
                        keys[2][m] = tempKey[m];
                    }
                    break;
                case 3:
                    for (m = 0; m < 48; m++) {
                        keys[3][m] = tempKey[m];
                    }
                    break;
                case 4:
                    for (m = 0; m < 48; m++) {
                        keys[4][m] = tempKey[m];
                    }
                    break;
                case 5:
                    for (m = 0; m < 48; m++) {
                        keys[5][m] = tempKey[m];
                    }
                    break;
                case 6:
                    for (m = 0; m < 48; m++) {
                        keys[6][m] = tempKey[m];
                    }
                    break;
                case 7:
                    for (m = 0; m < 48; m++) {
                        keys[7][m] = tempKey[m];
                    }
                    break;
                case 8:
                    for (m = 0; m < 48; m++) {
                        keys[8][m] = tempKey[m];
                    }
                    break;
                case 9:
                    for (m = 0; m < 48; m++) {
                        keys[9][m] = tempKey[m];
                    }
                    break;
                case 10:
                    for (m = 0; m < 48; m++) {
                        keys[10][m] = tempKey[m];
                    }
                    break;
                case 11:
                    for (m = 0; m < 48; m++) {
                        keys[11][m] = tempKey[m];
                    }
                    break;
                case 12:
                    for (m = 0; m < 48; m++) {
                        keys[12][m] = tempKey[m];
                    }
                    break;
                case 13:
                    for (m = 0; m < 48; m++) {
                        keys[13][m] = tempKey[m];
                    }
                    break;
                case 14:
                    for (m = 0; m < 48; m++) {
                        keys[14][m] = tempKey[m];
                    }
                    break;
                case 15:
                    for (m = 0; m < 48; m++) {
                        keys[15][m] = tempKey[m];
                    }
                    break;
            }
        }
        return keys;
    }
}
